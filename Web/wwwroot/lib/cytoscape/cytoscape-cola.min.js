/**
 * Minified by jsDelivr using UglifyJS v3.4.4.
 * Original file: /npm/cytoscape-cola@2.3.0/cytoscape-cola.js
 * 
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
!function (n, t) { "object" == typeof exports && "object" == typeof module ? module.exports = t(require("webcola")) : "function" == typeof define && define.amd ? define(["webcola"], t) : "object" == typeof exports ? exports.cytoscapeCola = t(require("webcola")) : n.cytoscapeCola = t(n.webcola) }(this, function (e) { return function (e) { var o = {}; function i(n) { if (o[n]) return o[n].exports; var t = o[n] = { i: n, l: !1, exports: {} }; return e[n].call(t.exports, t, t.exports, i), t.l = !0, t.exports } return i.m = e, i.c = o, i.i = function (n) { return n }, i.d = function (n, t, e) { i.o(n, t) || Object.defineProperty(n, t, { configurable: !1, enumerable: !0, get: e }) }, i.n = function (n) { var t = n && n.__esModule ? function () { return n.default } : function () { return n }; return i.d(t, "a", t), t }, i.o = function (n, t) { return Object.prototype.hasOwnProperty.call(n, t) }, i.p = "", i(i.s = 3) }([function (n, t, e) { "use strict"; var q = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (n) { return typeof n } : function (n) { return n && "function" == typeof Symbol && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n }, o = e(1), i = e(2), j = e(5) || ("undefined" != typeof window ? window.cola : null), I = e(4), O = function (n) { return (void 0 === n ? "undefined" : q(n)) === q(0) }, E = function () { }, C = function (n, t) { var e; return null != (e = n) && (void 0 === e ? "undefined" : q(e)) === q(function () { }) ? n.apply(t, [t]) : n }; function r(n) { this.options = o({}, i, n) } r.prototype.run = function () { var o = this, u = this.options; o.manuallyStopped = !1; var r = u.cy, n = u.eles, a = n.nodes(), t = n.edges(), c = !1, e = a.filter(function (n) { return n.isParent() }), s = a.subtract(e), l = u.boundingBox || { x1: 0, y1: 0, w: r.width(), h: r.height() }; void 0 === l.x2 && (l.x2 = l.x1 + l.w), void 0 === l.w && (l.w = l.x2 - l.x1), void 0 === l.y2 && (l.y2 = l.y1 + l.h), void 0 === l.h && (l.h = l.y2 - l.y1); var i = function () { for (var n = 0; n < a.length; n++) { var t = a[n], e = t.layoutDimensions(u), o = t.scratch("cola"); if (!o.updatedDims) { var i = C(u.nodeSpacing, t); o.width = e.w + 2 * i, o.height = e.h + 2 * i } } a.positions(function (n) { var t = n.scratch().cola, e = void 0; return !n.grabbed() && s.contains(n) && (e = { x: l.x1 + t.x, y: l.y1 + t.y }, O(e.x) && O(e.y) || (e = void 0)), e }), a.updateCompoundBounds(), c || (f(), c = !0), u.fit && r.fit(u.padding) }, d = function () { u.ungrabifyWhileSimulating && h.grabify(), r.off("destroy", g), a.off("grab free position", m), a.off("lock unlock", v), o.one("layoutstop", u.stop), o.trigger({ type: "layoutstop", layout: o }) }, f = function () { o.one("layoutready", u.ready), o.trigger({ type: "layoutready", layout: o }) }, p = u.refresh; p = u.refresh < 0 ? 1 : Math.max(1, p); var y = o.adaptor = j.adaptor({ trigger: function (n) { var t = j.EventType ? j.EventType.tick : null, e = j.EventType ? j.EventType.end : null; switch (n.type) { case "tick": case t: u.animate && i(); break; case "end": case e: i(), u.infinite || d() } }, kick: function () { var t = !0, e = function () { if (o.manuallyStopped) return d(), !0; var n = y.tick(); return u.infinite || t || y.convergenceThreshold(u.convergenceThreshold), t = !1, n && u.infinite && y.resume(), n }; if (u.animate) { I(function n() { (function () { for (var n = void 0, t = 0; t < p && !n; t++)n = n || e(); return n })() || I(n) }) } else for (; !e();); }, on: E, drag: E }); o.adaptor = y; var h = a.filter(":grabbable"); u.ungrabifyWhileSimulating && h.ungrabify(); var g = void 0; r.one("destroy", g = function () { o.stop() }); var m = void 0; a.on("grab free position", m = function (n) { var t = this.scratch().cola, e = this.position(); if (n.cyTarget === this || n.target === this) switch (n.type) { case "grab": y.dragstart(t); break; case "free": y.dragend(t); break; case "position": t.px === e.x - l.x1 && t.py === e.y - l.y1 || (t.px = e.x - l.x1, t.py = e.y - l.y1) } }); var v = void 0; a.on("lock unlock", v = function () { var n = this.scratch().cola; n.fixed = this.locked(), this.locked() ? y.dragstart(n) : y.dragend(n) }), y.nodes(s.map(function (n, t) { var e = C(u.nodeSpacing, n), o = n.position(), i = n.layoutDimensions(u); return n.scratch().cola = { x: u.randomize || void 0 === o.x ? Math.round(Math.random() * l.w) : o.x, y: u.randomize || void 0 === o.y ? Math.round(Math.random() * l.h) : o.y, width: i.w + 2 * e, height: i.h + 2 * e, index: t, fixed: n.locked() } })); var x = []; if (u.alignment) { var b = [], w = []; s.forEach(function (n) { var t = C(u.alignment, n), e = n.scratch().cola.index; t && (null != t.x && b.push({ node: e, offset: t.x }), null != t.y && w.push({ node: e, offset: t.y })) }), 0 < b.length && x.push({ type: "alignment", axis: "x", offsets: b }), 0 < w.length && x.push({ type: "alignment", axis: "y", offsets: w }) } u.gapInequalities && u.gapInequalities.forEach(function (n) { var t = n.left.scratch().cola.index, e = n.right.scratch().cola.index; x.push({ axis: n.axis, left: t, right: e, gap: n.gap, equality: n.equality }) }), 0 < x.length && y.constraints(x), y.groups(e.map(function (t, n) { var e = C(u.nodeSpacing, t), o = function (n) { return parseFloat(t.style("padding-" + n)) }, i = o("left") + e, r = o("right") + e, a = o("top") + e, c = o("bottom") + e; return t.scratch().cola = { index: n, padding: Math.max(i, r, a, c), leaves: t.children().intersection(s).map(function (n) { return n[0].scratch().cola.index }), fixed: t.locked() }, t }).map(function (n) { return n.scratch().cola.groups = n.children().intersection(e).map(function (n) { return n.scratch().cola.index }), n.scratch().cola })); var S = void 0, k = void 0; null != u.edgeLength ? (S = u.edgeLength, k = "linkDistance") : null != u.edgeSymDiffLength ? (S = u.edgeSymDiffLength, k = "symmetricDiffLinkLengths") : null != u.edgeJaccardLength ? (S = u.edgeJaccardLength, k = "jaccardLinkLengths") : (S = 100, k = "linkDistance"); var L, D; if (y.links(t.stdFilter(function (n) { return s.contains(n.source()) && s.contains(n.target()) }).map(function (n) { var t = n.scratch().cola = { source: n.source()[0].scratch().cola.index, target: n.target()[0].scratch().cola.index }; return null != S && (t.calcLength = C(S, n)), t })), y.size([l.w, l.h]), null != S && y[k](function (n) { return n.calcLength }), u.flow) { var T = void 0; (void 0 === (D = u.flow) ? "undefined" : q(D)) === q("") ? T = { axis: u.flow, minSeparation: 50 } : O(u.flow) ? T = { axis: "y", minSeparation: u.flow } : null != (L = u.flow) && (void 0 === L ? "undefined" : q(L)) === q({}) ? ((T = u.flow).axis = T.axis || "y", T.minSeparation = null != T.minSeparation ? T.minSeparation : 50) : T = { axis: "y", minSeparation: 50 }, y.flowLayout(T.axis, T.minSeparation) } return o.trigger({ type: "layoutstart", layout: o }), y.avoidOverlaps(u.avoidOverlap).handleDisconnected(u.handleDisconnected).start(u.unconstrIter, u.userConstIter, u.allConstIter), u.infinite || setTimeout(function () { o.manuallyStopped || y.stop() }, u.maxSimulationTime), this }, r.prototype.stop = function () { return this.adaptor && (this.manuallyStopped = !0, this.adaptor.stop()), this }, n.exports = r }, function (n, t, e) { "use strict"; n.exports = null != Object.assign ? Object.assign.bind(Object) : function (e) { for (var n = arguments.length, t = Array(1 < n ? n - 1 : 0), o = 1; o < n; o++)t[o - 1] = arguments[o]; return t.filter(function (n) { return null != n }).forEach(function (t) { Object.keys(t).forEach(function (n) { return e[n] = t[n] }) }), e } }, function (n, t, e) { "use strict"; var o = { animate: !0, refresh: 1, maxSimulationTime: 4e3, ungrabifyWhileSimulating: !1, fit: !0, padding: 30, boundingBox: void 0, nodeDimensionsIncludeLabels: !1, ready: function () { }, stop: function () { }, randomize: !1, avoidOverlap: !0, handleDisconnected: !0, convergenceThreshold: .01, nodeSpacing: function (n) { return 10 }, flow: void 0, alignment: void 0, gapInequalities: void 0, edgeLength: void 0, edgeSymDiffLength: void 0, edgeJaccardLength: void 0, unconstrIter: void 0, userConstIter: void 0, allConstIter: void 0, infinite: !1 }; n.exports = o }, function (n, t, e) { "use strict"; var o = e(0), i = function (n) { n && n("layout", "cola", o) }; "undefined" != typeof cytoscape && i(cytoscape), n.exports = i }, function (n, t, e) { "use strict"; var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (n) { return typeof n } : function (n) { return n && "function" == typeof Symbol && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n }, i = void 0; i = "undefined" !== ("undefined" == typeof window ? "undefined" : o(window)) ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (n) { return setTimeout(n, 16) } : function (n) { n() }, n.exports = i }, function (n, t) { n.exports = e }]) });
//# sourceMappingURL=/sm/b5acdf6aad4a2fa73b92c1c473db1c552bb169ce504d250072d07533d15412e7.map